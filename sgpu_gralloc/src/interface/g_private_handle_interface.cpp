///
/// @file g_private_handle_interface.cpp
/// @copyright 2021-2022 Samsung Electronics
///

/// THIS IS AN AUTOGENERATED FILE ///
///   DO NOT EDIT THIS FILE       ///

#include <stdint.h>

#include <cutils/log.h>
#include <cutils/native_handle.h>

#include "metadata_gpu.h"
#include "metadata_gralloc.h"
#include "private_handle.h"

#include "g_private_handle_interface.h"

int sgr_intf_get_private_handle_t_fds(const struct native_handle *handle, int fds_index)
{
        if (fds_index >= 5) {
                ALOGE("Array access out of bounds. fds_index = %d. Array size is 5", fds_index);
                return 0;
        }

        const struct private_handle_t *priv_hnd = (const struct private_handle_t *)handle;

        return priv_hnd->fds[fds_index];
}

uint32_t sgr_intf_get_private_handle_t_magic(const struct native_handle *handle)
{
        const struct private_handle_t *priv_hnd = (const struct private_handle_t *)handle;

        return priv_hnd->magic;
}

uint64_t sgr_intf_get_private_handle_t_reserved_region_size(const struct native_handle *handle)
{
        const struct private_handle_t *priv_hnd = (const struct private_handle_t *)handle;

        return priv_hnd->reserved_region_size;
}

int sgr_intf_get_private_handle_t_handles(const struct native_handle *handle, int handles_index)
{
        if (handles_index >= 5) {
                ALOGE("Array access out of bounds. handles_index = %d. Array size is 5", handles_index);
                return 0;
        }

        const struct private_handle_t *priv_hnd = (const struct private_handle_t *)handle;

        return priv_hnd->handles[handles_index];
}

uint64_t sgr_intf_get_private_handle_t_alloc_bases(const struct native_handle *handle, int alloc_bases_index)
{
        if (alloc_bases_index >= 4) {
                ALOGE("Array access out of bounds. alloc_bases_index = %d. Array size is 4", alloc_bases_index);
                return 0;
        }

        const struct private_handle_t *priv_hnd = (const struct private_handle_t *)handle;

        return priv_hnd->alloc_bases[alloc_bases_index];
}

uint64_t sgr_intf_get_private_handle_t_metadata_base(const struct native_handle *handle)
{
        const struct private_handle_t *priv_hnd = (const struct private_handle_t *)handle;

        return priv_hnd->metadata_base;
}

int sgr_intf_get_private_handle_t_pid(const struct native_handle *handle)
{
        const struct private_handle_t *priv_hnd = (const struct private_handle_t *)handle;

        return priv_hnd->pid;
}

uint64_t sgr_intf_get_private_handle_t_lock_cpu_usage(const struct native_handle *handle)
{
        const struct private_handle_t *priv_hnd = (const struct private_handle_t *)handle;

        return priv_hnd->lock_cpu_usage;
}

int sgr_intf_get_private_handle_t_lock_count(const struct native_handle *handle)
{
        const struct private_handle_t *priv_hnd = (const struct private_handle_t *)handle;

        return priv_hnd->lock_count;
}

uint32_t sgr_intf_get_private_handle_t_width(const struct native_handle *handle)
{
        const struct private_handle_t *priv_hnd = (const struct private_handle_t *)handle;

        return priv_hnd->width;
}

uint32_t sgr_intf_get_private_handle_t_height(const struct native_handle *handle)
{
        const struct private_handle_t *priv_hnd = (const struct private_handle_t *)handle;

        return priv_hnd->height;
}

uint32_t sgr_intf_get_private_handle_t_format(const struct native_handle *handle)
{
        const struct private_handle_t *priv_hnd = (const struct private_handle_t *)handle;

        return priv_hnd->format;
}

uint64_t sgr_intf_get_private_handle_t_usage(const struct native_handle *handle)
{
        const struct private_handle_t *priv_hnd = (const struct private_handle_t *)handle;

        return priv_hnd->usage;
}

uint32_t sgr_intf_get_private_handle_t_alloc_width(const struct native_handle *handle)
{
        const struct private_handle_t *priv_hnd = (const struct private_handle_t *)handle;

        return priv_hnd->alloc_width;
}

uint32_t sgr_intf_get_private_handle_t_alloc_height(const struct native_handle *handle)
{
        const struct private_handle_t *priv_hnd = (const struct private_handle_t *)handle;

        return priv_hnd->alloc_height;
}

uint32_t sgr_intf_get_private_handle_t_alloc_format(const struct native_handle *handle)
{
        const struct private_handle_t *priv_hnd = (const struct private_handle_t *)handle;

        return priv_hnd->alloc_format;
}

uint32_t sgr_intf_get_private_handle_t_alloc_layout(const struct native_handle *handle)
{
        const struct private_handle_t *priv_hnd = (const struct private_handle_t *)handle;

        return priv_hnd->alloc_layout;
}

uint32_t sgr_intf_get_private_handle_t_num_planes(const struct native_handle *handle)
{
        const struct private_handle_t *priv_hnd = (const struct private_handle_t *)handle;

        return priv_hnd->num_planes;
}

uint32_t sgr_intf_get_private_handle_t_num_allocs(const struct native_handle *handle)
{
        const struct private_handle_t *priv_hnd = (const struct private_handle_t *)handle;

        return priv_hnd->num_allocs;
}

int64_t sgr_intf_get_private_handle_t_plane_infos_size(const struct native_handle *handle, int plane_infos_index)
{
        if (plane_infos_index >= 4) {
                ALOGE("Array access out of bounds. plane_infos_index = %d. Array size is 4", plane_infos_index);
                return 0;
        }

        const struct private_handle_t *priv_hnd = (const struct private_handle_t *)handle;

        return priv_hnd->plane_infos[plane_infos_index].size;
}

int64_t sgr_intf_get_private_handle_t_plane_infos_offset(const struct native_handle *handle, int plane_infos_index)
{
        if (plane_infos_index >= 4) {
                ALOGE("Array access out of bounds. plane_infos_index = %d. Array size is 4", plane_infos_index);
                return 0;
        }

        const struct private_handle_t *priv_hnd = (const struct private_handle_t *)handle;

        return priv_hnd->plane_infos[plane_infos_index].offset;
}

int64_t sgr_intf_get_private_handle_t_plane_infos_stride_in_bytes(const struct native_handle *handle, int plane_infos_index)
{
        if (plane_infos_index >= 4) {
                ALOGE("Array access out of bounds. plane_infos_index = %d. Array size is 4", plane_infos_index);
                return 0;
        }

        const struct private_handle_t *priv_hnd = (const struct private_handle_t *)handle;

        return priv_hnd->plane_infos[plane_infos_index].stride_in_bytes;
}

int64_t sgr_intf_get_private_handle_t_plane_infos_width_in_samples(const struct native_handle *handle, int plane_infos_index)
{
        if (plane_infos_index >= 4) {
                ALOGE("Array access out of bounds. plane_infos_index = %d. Array size is 4", plane_infos_index);
                return 0;
        }

        const struct private_handle_t *priv_hnd = (const struct private_handle_t *)handle;

        return priv_hnd->plane_infos[plane_infos_index].width_in_samples;
}

int64_t sgr_intf_get_private_handle_t_plane_infos_height_in_samples(const struct native_handle *handle, int plane_infos_index)
{
        if (plane_infos_index >= 4) {
                ALOGE("Array access out of bounds. plane_infos_index = %d. Array size is 4", plane_infos_index);
                return 0;
        }

        const struct private_handle_t *priv_hnd = (const struct private_handle_t *)handle;

        return priv_hnd->plane_infos[plane_infos_index].height_in_samples;
}

uint32_t sgr_intf_get_private_handle_t_alloc_infos_size(const struct native_handle *handle, int alloc_infos_index)
{
        if (alloc_infos_index >= 4) {
                ALOGE("Array access out of bounds. alloc_infos_index = %d. Array size is 4", alloc_infos_index);
                return 0;
        }

        const struct private_handle_t *priv_hnd = (const struct private_handle_t *)handle;

        return priv_hnd->alloc_infos[alloc_infos_index].size;
}

uint32_t sgr_intf_get_private_handle_t_alloc_infos_key_offset(const struct native_handle *handle, int alloc_infos_index)
{
        if (alloc_infos_index >= 4) {
                ALOGE("Array access out of bounds. alloc_infos_index = %d. Array size is 4", alloc_infos_index);
                return 0;
        }

        const struct private_handle_t *priv_hnd = (const struct private_handle_t *)handle;

        return priv_hnd->alloc_infos[alloc_infos_index].key_offset;
}

uint32_t sgr_intf_get_private_handle_t_major_version(const struct native_handle *handle)
{
        const struct private_handle_t *priv_hnd = (const struct private_handle_t *)handle;

        return priv_hnd->major_version;
}

uint32_t sgr_intf_get_private_handle_t_minor_version(const struct native_handle *handle)
{
        const struct private_handle_t *priv_hnd = (const struct private_handle_t *)handle;

        return priv_hnd->minor_version;
}

uint64_t sgr_intf_get_sgr_metadata_buffer_id(const struct native_handle *handle)
{
        const struct sgr_metadata *metadata = sgr_get_metadata(handle);

        return metadata->buffer_id;
}

uint64_t sgr_intf_get_sgr_metadata_length_name(const struct native_handle *handle)
{
        const struct sgr_metadata *metadata = sgr_get_metadata(handle);

        return metadata->length_name;
}

uint64_t sgr_intf_get_sgr_metadata_width(const struct native_handle *handle)
{
        const struct sgr_metadata *metadata = sgr_get_metadata(handle);

        return metadata->width;
}

uint64_t sgr_intf_get_sgr_metadata_height(const struct native_handle *handle)
{
        const struct sgr_metadata *metadata = sgr_get_metadata(handle);

        return metadata->height;
}

uint64_t sgr_intf_get_sgr_metadata_layer_count(const struct native_handle *handle)
{
        const struct sgr_metadata *metadata = sgr_get_metadata(handle);

        return metadata->layer_count;
}

int32_t sgr_intf_get_sgr_metadata_pixel_format_requested(const struct native_handle *handle)
{
        const struct sgr_metadata *metadata = sgr_get_metadata(handle);

        return metadata->pixel_format_requested;
}

uint32_t sgr_intf_get_sgr_metadata_pixel_format_fourcc(const struct native_handle *handle)
{
        const struct sgr_metadata *metadata = sgr_get_metadata(handle);

        return metadata->pixel_format_fourcc;
}

uint64_t sgr_intf_get_sgr_metadata_pixel_format_modifier(const struct native_handle *handle)
{
        const struct sgr_metadata *metadata = sgr_get_metadata(handle);

        return metadata->pixel_format_modifier;
}

uint64_t sgr_intf_get_sgr_metadata_usage(const struct native_handle *handle)
{
        const struct sgr_metadata *metadata = sgr_get_metadata(handle);

        return metadata->usage;
}

uint64_t sgr_intf_get_sgr_metadata_allocation_size(const struct native_handle *handle)
{
        const struct sgr_metadata *metadata = sgr_get_metadata(handle);

        return metadata->allocation_size;
}

uint64_t sgr_intf_get_sgr_metadata_protected_content(const struct native_handle *handle)
{
        const struct sgr_metadata *metadata = sgr_get_metadata(handle);

        return metadata->protected_content;
}

uint32_t sgr_intf_get_sgr_metadata_compression(const struct native_handle *handle)
{
        const struct sgr_metadata *metadata = sgr_get_metadata(handle);

        return metadata->compression;
}

uint32_t sgr_intf_get_sgr_metadata_interlaced(const struct native_handle *handle)
{
        const struct sgr_metadata *metadata = sgr_get_metadata(handle);

        return metadata->interlaced;
}

uint32_t sgr_intf_get_sgr_metadata_chroma_siting(const struct native_handle *handle)
{
        const struct sgr_metadata *metadata = sgr_get_metadata(handle);

        return metadata->chroma_siting;
}

uint64_t sgr_intf_get_sgr_metadata_num_plane_layouts(const struct native_handle *handle)
{
        const struct sgr_metadata *metadata = sgr_get_metadata(handle);

        return metadata->num_plane_layouts;
}

int64_t sgr_intf_get_sgr_metadata_plane_layouts_num_components(const struct native_handle *handle, int plane_layouts_index)
{
        if (plane_layouts_index >= 4) {
                ALOGE("Array access out of bounds. plane_layouts_index = %d. Array size is 4", plane_layouts_index);
                return 0;
        }

        const struct sgr_metadata *metadata = sgr_get_metadata(handle);

        return metadata->plane_layouts[plane_layouts_index].num_components;
}

int64_t sgr_intf_get_sgr_metadata_plane_layouts_components_component_type(const struct native_handle *handle, int plane_layouts_index, int components_index)
{
        if (plane_layouts_index >= 4) {
                ALOGE("Array access out of bounds. plane_layouts_index = %d. Array size is 4", plane_layouts_index);
                return 0;
        }

        if (components_index >= 4) {
                ALOGE("Array access out of bounds. components_index = %d. Array size is 4", components_index);
                return 0;
        }

        const struct sgr_metadata *metadata = sgr_get_metadata(handle);

        return metadata->plane_layouts[plane_layouts_index].components[components_index].component_type;
}

int64_t sgr_intf_get_sgr_metadata_plane_layouts_components_offset_in_bits(const struct native_handle *handle, int plane_layouts_index, int components_index)
{
        if (plane_layouts_index >= 4) {
                ALOGE("Array access out of bounds. plane_layouts_index = %d. Array size is 4", plane_layouts_index);
                return 0;
        }

        if (components_index >= 4) {
                ALOGE("Array access out of bounds. components_index = %d. Array size is 4", components_index);
                return 0;
        }

        const struct sgr_metadata *metadata = sgr_get_metadata(handle);

        return metadata->plane_layouts[plane_layouts_index].components[components_index].offset_in_bits;
}

int64_t sgr_intf_get_sgr_metadata_plane_layouts_components_size_in_bits(const struct native_handle *handle, int plane_layouts_index, int components_index)
{
        if (plane_layouts_index >= 4) {
                ALOGE("Array access out of bounds. plane_layouts_index = %d. Array size is 4", plane_layouts_index);
                return 0;
        }

        if (components_index >= 4) {
                ALOGE("Array access out of bounds. components_index = %d. Array size is 4", components_index);
                return 0;
        }

        const struct sgr_metadata *metadata = sgr_get_metadata(handle);

        return metadata->plane_layouts[plane_layouts_index].components[components_index].size_in_bits;
}

int64_t sgr_intf_get_sgr_metadata_plane_layouts_offset_in_bytes(const struct native_handle *handle, int plane_layouts_index)
{
        if (plane_layouts_index >= 4) {
                ALOGE("Array access out of bounds. plane_layouts_index = %d. Array size is 4", plane_layouts_index);
                return 0;
        }

        const struct sgr_metadata *metadata = sgr_get_metadata(handle);

        return metadata->plane_layouts[plane_layouts_index].offset_in_bytes;
}

int64_t sgr_intf_get_sgr_metadata_plane_layouts_sample_increment_in_bits(const struct native_handle *handle, int plane_layouts_index)
{
        if (plane_layouts_index >= 4) {
                ALOGE("Array access out of bounds. plane_layouts_index = %d. Array size is 4", plane_layouts_index);
                return 0;
        }

        const struct sgr_metadata *metadata = sgr_get_metadata(handle);

        return metadata->plane_layouts[plane_layouts_index].sample_increment_in_bits;
}

int64_t sgr_intf_get_sgr_metadata_plane_layouts_stride_in_bytes(const struct native_handle *handle, int plane_layouts_index)
{
        if (plane_layouts_index >= 4) {
                ALOGE("Array access out of bounds. plane_layouts_index = %d. Array size is 4", plane_layouts_index);
                return 0;
        }

        const struct sgr_metadata *metadata = sgr_get_metadata(handle);

        return metadata->plane_layouts[plane_layouts_index].stride_in_bytes;
}

int64_t sgr_intf_get_sgr_metadata_plane_layouts_width_in_samples(const struct native_handle *handle, int plane_layouts_index)
{
        if (plane_layouts_index >= 4) {
                ALOGE("Array access out of bounds. plane_layouts_index = %d. Array size is 4", plane_layouts_index);
                return 0;
        }

        const struct sgr_metadata *metadata = sgr_get_metadata(handle);

        return metadata->plane_layouts[plane_layouts_index].width_in_samples;
}

int64_t sgr_intf_get_sgr_metadata_plane_layouts_height_in_samples(const struct native_handle *handle, int plane_layouts_index)
{
        if (plane_layouts_index >= 4) {
                ALOGE("Array access out of bounds. plane_layouts_index = %d. Array size is 4", plane_layouts_index);
                return 0;
        }

        const struct sgr_metadata *metadata = sgr_get_metadata(handle);

        return metadata->plane_layouts[plane_layouts_index].height_in_samples;
}

int64_t sgr_intf_get_sgr_metadata_plane_layouts_total_size_in_bytes(const struct native_handle *handle, int plane_layouts_index)
{
        if (plane_layouts_index >= 4) {
                ALOGE("Array access out of bounds. plane_layouts_index = %d. Array size is 4", plane_layouts_index);
                return 0;
        }

        const struct sgr_metadata *metadata = sgr_get_metadata(handle);

        return metadata->plane_layouts[plane_layouts_index].total_size_in_bytes;
}

int64_t sgr_intf_get_sgr_metadata_plane_layouts_horizontal_subsampling(const struct native_handle *handle, int plane_layouts_index)
{
        if (plane_layouts_index >= 4) {
                ALOGE("Array access out of bounds. plane_layouts_index = %d. Array size is 4", plane_layouts_index);
                return 0;
        }

        const struct sgr_metadata *metadata = sgr_get_metadata(handle);

        return metadata->plane_layouts[plane_layouts_index].horizontal_subsampling;
}

int64_t sgr_intf_get_sgr_metadata_plane_layouts_vertical_subsampling(const struct native_handle *handle, int plane_layouts_index)
{
        if (plane_layouts_index >= 4) {
                ALOGE("Array access out of bounds. plane_layouts_index = %d. Array size is 4", plane_layouts_index);
                return 0;
        }

        const struct sgr_metadata *metadata = sgr_get_metadata(handle);

        return metadata->plane_layouts[plane_layouts_index].vertical_subsampling;
}

uint64_t sgr_intf_get_sgr_metadata_num_crops(const struct native_handle *handle)
{
        const struct sgr_metadata *metadata = sgr_get_metadata(handle);

        return metadata->num_crops;
}

int32_t sgr_intf_get_sgr_metadata_crops_left(const struct native_handle *handle, int crops_index)
{
        if (crops_index >= 4) {
                ALOGE("Array access out of bounds. crops_index = %d. Array size is 4", crops_index);
                return 0;
        }

        const struct sgr_metadata *metadata = sgr_get_metadata(handle);

        return metadata->crops[crops_index].left;
}

int32_t sgr_intf_get_sgr_metadata_crops_top(const struct native_handle *handle, int crops_index)
{
        if (crops_index >= 4) {
                ALOGE("Array access out of bounds. crops_index = %d. Array size is 4", crops_index);
                return 0;
        }

        const struct sgr_metadata *metadata = sgr_get_metadata(handle);

        return metadata->crops[crops_index].top;
}

int32_t sgr_intf_get_sgr_metadata_crops_right(const struct native_handle *handle, int crops_index)
{
        if (crops_index >= 4) {
                ALOGE("Array access out of bounds. crops_index = %d. Array size is 4", crops_index);
                return 0;
        }

        const struct sgr_metadata *metadata = sgr_get_metadata(handle);

        return metadata->crops[crops_index].right;
}

int32_t sgr_intf_get_sgr_metadata_crops_bottom(const struct native_handle *handle, int crops_index)
{
        if (crops_index >= 4) {
                ALOGE("Array access out of bounds. crops_index = %d. Array size is 4", crops_index);
                return 0;
        }

        const struct sgr_metadata *metadata = sgr_get_metadata(handle);

        return metadata->crops[crops_index].bottom;
}

int32_t sgr_intf_get_sgr_metadata_dataspace(const struct native_handle *handle)
{
        const struct sgr_metadata *metadata = sgr_get_metadata(handle);

        return metadata->dataspace;
}

int32_t sgr_intf_get_sgr_metadata_blend_mode(const struct native_handle *handle)
{
        const struct sgr_metadata *metadata = sgr_get_metadata(handle);

        return metadata->blend_mode;
}

bool sgr_intf_get_sgr_metadata_is_smpte2086_set(const struct native_handle *handle)
{
        const struct sgr_metadata *metadata = sgr_get_metadata(handle);

        return metadata->is_smpte2086_set;
}

float sgr_intf_get_sgr_metadata_smpte2086_primary_red_x(const struct native_handle *handle)
{
        const struct sgr_metadata *metadata = sgr_get_metadata(handle);

        return metadata->smpte2086.primary_red.x;
}

float sgr_intf_get_sgr_metadata_smpte2086_primary_red_y(const struct native_handle *handle)
{
        const struct sgr_metadata *metadata = sgr_get_metadata(handle);

        return metadata->smpte2086.primary_red.y;
}

float sgr_intf_get_sgr_metadata_smpte2086_primary_green_x(const struct native_handle *handle)
{
        const struct sgr_metadata *metadata = sgr_get_metadata(handle);

        return metadata->smpte2086.primary_green.x;
}

float sgr_intf_get_sgr_metadata_smpte2086_primary_green_y(const struct native_handle *handle)
{
        const struct sgr_metadata *metadata = sgr_get_metadata(handle);

        return metadata->smpte2086.primary_green.y;
}

float sgr_intf_get_sgr_metadata_smpte2086_primary_blue_x(const struct native_handle *handle)
{
        const struct sgr_metadata *metadata = sgr_get_metadata(handle);

        return metadata->smpte2086.primary_blue.x;
}

float sgr_intf_get_sgr_metadata_smpte2086_primary_blue_y(const struct native_handle *handle)
{
        const struct sgr_metadata *metadata = sgr_get_metadata(handle);

        return metadata->smpte2086.primary_blue.y;
}

float sgr_intf_get_sgr_metadata_smpte2086_white_point_x(const struct native_handle *handle)
{
        const struct sgr_metadata *metadata = sgr_get_metadata(handle);

        return metadata->smpte2086.white_point.x;
}

float sgr_intf_get_sgr_metadata_smpte2086_white_point_y(const struct native_handle *handle)
{
        const struct sgr_metadata *metadata = sgr_get_metadata(handle);

        return metadata->smpte2086.white_point.y;
}

float sgr_intf_get_sgr_metadata_smpte2086_max_luminance(const struct native_handle *handle)
{
        const struct sgr_metadata *metadata = sgr_get_metadata(handle);

        return metadata->smpte2086.max_luminance;
}

float sgr_intf_get_sgr_metadata_smpte2086_min_luminance(const struct native_handle *handle)
{
        const struct sgr_metadata *metadata = sgr_get_metadata(handle);

        return metadata->smpte2086.min_luminance;
}

bool sgr_intf_get_sgr_metadata_is_cta861_3_set(const struct native_handle *handle)
{
        const struct sgr_metadata *metadata = sgr_get_metadata(handle);

        return metadata->is_cta861_3_set;
}

float sgr_intf_get_sgr_metadata_cta861_3_max_content_light_level(const struct native_handle *handle)
{
        const struct sgr_metadata *metadata = sgr_get_metadata(handle);

        return metadata->cta861_3.max_content_light_level;
}

float sgr_intf_get_sgr_metadata_cta861_3_max_frame_average_light_level(const struct native_handle *handle)
{
        const struct sgr_metadata *metadata = sgr_get_metadata(handle);

        return metadata->cta861_3.max_frame_average_light_level;
}

uint64_t sgr_intf_get_sgr_metadata_length_smpte2094_40(const struct native_handle *handle)
{
        const struct sgr_metadata *metadata = sgr_get_metadata(handle);

        return metadata->length_smpte2094_40;
}

uint8_t sgr_intf_get_sgr_metadata_smpte2094_40(const struct native_handle *handle, int smpte2094_40_index)
{
        if (smpte2094_40_index >= 1024) {
                ALOGE("Array access out of bounds. smpte2094_40_index = %d. Array size is 1024", smpte2094_40_index);
                return 0;
        }

        const struct sgr_metadata *metadata = sgr_get_metadata(handle);

        return metadata->smpte2094_40[smpte2094_40_index];
}

uint32_t sgr_intf_get_sgr_metadata_alloc_width(const struct native_handle *handle)
{
        const struct sgr_metadata *metadata = sgr_get_metadata(handle);

        return metadata->alloc_width;
}

uint32_t sgr_intf_get_sgr_metadata_alloc_height(const struct native_handle *handle)
{
        const struct sgr_metadata *metadata = sgr_get_metadata(handle);

        return metadata->alloc_height;
}

uint32_t sgr_intf_get_sgr_metadata_alloc_format(const struct native_handle *handle)
{
        const struct sgr_metadata *metadata = sgr_get_metadata(handle);

        return metadata->alloc_format;
}

uint32_t sgr_intf_get_sgr_metadata_alloc_layout(const struct native_handle *handle)
{
        const struct sgr_metadata *metadata = sgr_get_metadata(handle);

        return metadata->alloc_layout;
}

uint32_t sgr_intf_get_sgr_metadata_num_allocs(const struct native_handle *handle)
{
        const struct sgr_metadata *metadata = sgr_get_metadata(handle);

        return metadata->num_allocs;
}

uint32_t sgr_intf_get_sgr_metadata_allocs_alignment(const struct native_handle *handle, int allocs_index)
{
        if (allocs_index >= 4) {
                ALOGE("Array access out of bounds. allocs_index = %d. Array size is 4", allocs_index);
                return 0;
        }

        const struct sgr_metadata *metadata = sgr_get_metadata(handle);

        return metadata->allocs[allocs_index].alignment;
}

uint32_t sgr_intf_get_sgr_metadata_allocs_total_size(const struct native_handle *handle, int allocs_index)
{
        if (allocs_index >= 4) {
                ALOGE("Array access out of bounds. allocs_index = %d. Array size is 4", allocs_index);
                return 0;
        }

        const struct sgr_metadata *metadata = sgr_get_metadata(handle);

        return metadata->allocs[allocs_index].total_size;
}

uint32_t sgr_intf_get_sgr_metadata_allocs_data_offset(const struct native_handle *handle, int allocs_index)
{
        if (allocs_index >= 4) {
                ALOGE("Array access out of bounds. allocs_index = %d. Array size is 4", allocs_index);
                return 0;
        }

        const struct sgr_metadata *metadata = sgr_get_metadata(handle);

        return metadata->allocs[allocs_index].data.offset;
}

uint32_t sgr_intf_get_sgr_metadata_allocs_data_size(const struct native_handle *handle, int allocs_index)
{
        if (allocs_index >= 4) {
                ALOGE("Array access out of bounds. allocs_index = %d. Array size is 4", allocs_index);
                return 0;
        }

        const struct sgr_metadata *metadata = sgr_get_metadata(handle);

        return metadata->allocs[allocs_index].data.size;
}

uint32_t sgr_intf_get_sgr_metadata_allocs_key_offset(const struct native_handle *handle, int allocs_index)
{
        if (allocs_index >= 4) {
                ALOGE("Array access out of bounds. allocs_index = %d. Array size is 4", allocs_index);
                return 0;
        }

        const struct sgr_metadata *metadata = sgr_get_metadata(handle);

        return metadata->allocs[allocs_index].key.offset;
}

uint32_t sgr_intf_get_sgr_metadata_allocs_key_size(const struct native_handle *handle, int allocs_index)
{
        if (allocs_index >= 4) {
                ALOGE("Array access out of bounds. allocs_index = %d. Array size is 4", allocs_index);
                return 0;
        }

        const struct sgr_metadata *metadata = sgr_get_metadata(handle);

        return metadata->allocs[allocs_index].key.size;
}

uint32_t sgr_intf_get_sgr_metadata_allocs_payload_offset(const struct native_handle *handle, int allocs_index, int payload_index)
{
        if (allocs_index >= 4) {
                ALOGE("Array access out of bounds. allocs_index = %d. Array size is 4", allocs_index);
                return 0;
        }

        if (payload_index >= 2) {
                ALOGE("Array access out of bounds. payload_index = %d. Array size is 2", payload_index);
                return 0;
        }

        const struct sgr_metadata *metadata = sgr_get_metadata(handle);

        return metadata->allocs[allocs_index].payload[payload_index].offset;
}

uint32_t sgr_intf_get_sgr_metadata_allocs_payload_size(const struct native_handle *handle, int allocs_index, int payload_index)
{
        if (allocs_index >= 4) {
                ALOGE("Array access out of bounds. allocs_index = %d. Array size is 4", allocs_index);
                return 0;
        }

        if (payload_index >= 2) {
                ALOGE("Array access out of bounds. payload_index = %d. Array size is 2", payload_index);
                return 0;
        }

        const struct sgr_metadata *metadata = sgr_get_metadata(handle);

        return metadata->allocs[allocs_index].payload[payload_index].size;
}

uint32_t sgr_intf_get_sgr_metadata_allocs_header_offset(const struct native_handle *handle, int allocs_index, int header_index)
{
        if (allocs_index >= 4) {
                ALOGE("Array access out of bounds. allocs_index = %d. Array size is 4", allocs_index);
                return 0;
        }

        if (header_index >= 2) {
                ALOGE("Array access out of bounds. header_index = %d. Array size is 2", header_index);
                return 0;
        }

        const struct sgr_metadata *metadata = sgr_get_metadata(handle);

        return metadata->allocs[allocs_index].header[header_index].offset;
}

uint32_t sgr_intf_get_sgr_metadata_allocs_header_size(const struct native_handle *handle, int allocs_index, int header_index)
{
        if (allocs_index >= 4) {
                ALOGE("Array access out of bounds. allocs_index = %d. Array size is 4", allocs_index);
                return 0;
        }

        if (header_index >= 2) {
                ALOGE("Array access out of bounds. header_index = %d. Array size is 2", header_index);
                return 0;
        }

        const struct sgr_metadata *metadata = sgr_get_metadata(handle);

        return metadata->allocs[allocs_index].header[header_index].size;
}

bool sgr_intf_get_sgr_metadata_sub_valid(const struct native_handle *handle)
{
        const struct sgr_metadata *metadata = sgr_get_metadata(handle);

        return metadata->sub_valid;
}

uint32_t sgr_intf_get_sgr_metadata_gpu_dcc_sw_mode(const struct native_handle *handle)
{
        const struct sgr_metadata_gpu *metadata_gpu = (const sgr_metadata_gpu *)sgr_get_metadata_gpu(handle);

        return metadata_gpu->dcc_sw_mode;
}

void sgr_intf_set_sgr_metadata_gpu_dcc_sw_mode(struct native_handle *handle, const uint32_t set_val)
{
        struct sgr_metadata_gpu *metadata_gpu = (struct sgr_metadata_gpu *)sgr_get_metadata_gpu(handle);

        metadata_gpu->dcc_sw_mode = set_val;
}

uint32_t sgr_intf_get_sgr_metadata_gpu_dcc_is_pipe_aligned(const struct native_handle *handle)
{
        const struct sgr_metadata_gpu *metadata_gpu = (const sgr_metadata_gpu *)sgr_get_metadata_gpu(handle);

        return metadata_gpu->dcc_is_pipe_aligned;
}

void sgr_intf_set_sgr_metadata_gpu_dcc_is_pipe_aligned(struct native_handle *handle, const uint32_t set_val)
{
        struct sgr_metadata_gpu *metadata_gpu = (struct sgr_metadata_gpu *)sgr_get_metadata_gpu(handle);

        metadata_gpu->dcc_is_pipe_aligned = set_val;
}

uint32_t sgr_intf_get_sgr_metadata_gpu_dcc_max_uncompressed_block_size(const struct native_handle *handle)
{
        const struct sgr_metadata_gpu *metadata_gpu = (const sgr_metadata_gpu *)sgr_get_metadata_gpu(handle);

        return metadata_gpu->dcc_max_uncompressed_block_size;
}

void sgr_intf_set_sgr_metadata_gpu_dcc_max_uncompressed_block_size(struct native_handle *handle, const uint32_t set_val)
{
        struct sgr_metadata_gpu *metadata_gpu = (struct sgr_metadata_gpu *)sgr_get_metadata_gpu(handle);

        metadata_gpu->dcc_max_uncompressed_block_size = set_val;
}

uint32_t sgr_intf_get_sgr_metadata_gpu_dcc_max_compressed_block_size(const struct native_handle *handle)
{
        const struct sgr_metadata_gpu *metadata_gpu = (const sgr_metadata_gpu *)sgr_get_metadata_gpu(handle);

        return metadata_gpu->dcc_max_compressed_block_size;
}

void sgr_intf_set_sgr_metadata_gpu_dcc_max_compressed_block_size(struct native_handle *handle, const uint32_t set_val)
{
        struct sgr_metadata_gpu *metadata_gpu = (struct sgr_metadata_gpu *)sgr_get_metadata_gpu(handle);

        metadata_gpu->dcc_max_compressed_block_size = set_val;
}

uint32_t sgr_intf_get_sgr_metadata_gpu_dcc_independent_block_size_64(const struct native_handle *handle)
{
        const struct sgr_metadata_gpu *metadata_gpu = (const sgr_metadata_gpu *)sgr_get_metadata_gpu(handle);

        return metadata_gpu->dcc_independent_block_size_64;
}

void sgr_intf_set_sgr_metadata_gpu_dcc_independent_block_size_64(struct native_handle *handle, const uint32_t set_val)
{
        struct sgr_metadata_gpu *metadata_gpu = (struct sgr_metadata_gpu *)sgr_get_metadata_gpu(handle);

        metadata_gpu->dcc_independent_block_size_64 = set_val;
}

uint32_t sgr_intf_get_sgr_metadata_gpu_dcc_independent_block_size_128(const struct native_handle *handle)
{
        const struct sgr_metadata_gpu *metadata_gpu = (const sgr_metadata_gpu *)sgr_get_metadata_gpu(handle);

        return metadata_gpu->dcc_independent_block_size_128;
}

void sgr_intf_set_sgr_metadata_gpu_dcc_independent_block_size_128(struct native_handle *handle, const uint32_t set_val)
{
        struct sgr_metadata_gpu *metadata_gpu = (struct sgr_metadata_gpu *)sgr_get_metadata_gpu(handle);

        metadata_gpu->dcc_independent_block_size_128 = set_val;
}

uint32_t sgr_intf_get_sgr_metadata_gpu_is_metadata_initialized(const struct native_handle *handle)
{
        const struct sgr_metadata_gpu *metadata_gpu = (const sgr_metadata_gpu *)sgr_get_metadata_gpu(handle);

        return metadata_gpu->is_metadata_initialized;
}

void sgr_intf_set_sgr_metadata_gpu_is_metadata_initialized(struct native_handle *handle, const uint32_t set_val)
{
        struct sgr_metadata_gpu *metadata_gpu = (struct sgr_metadata_gpu *)sgr_get_metadata_gpu(handle);

        metadata_gpu->is_metadata_initialized = set_val;
}
